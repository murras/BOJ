# Chapter 4 세그먼트 트리 활용하기

---
## 01 최소값 찾기(p.2)

>[히스토그램에서 가장 큰 직사각형_6549](http://icpc.me/6549)
- 왼쪽 끝 - 오른쪽 끝을 변으로 하는 직사각형 높이 = 히스토그램에서 가장 낮은 막대의 높이와 같다.
- 막대를 지정하고 그 막대를 높이로 하는 가장 큰 직사각형을 구한다.
- 이때 시간 복잡도 O(N) * O(N) = O(N^2)
- 가장 낮은 막대 번호를 m 이라고 했을때 m의 왼쪽, 오른쪽으로 나눠서 문제를 푼다.
- 나눈 히스토그램에서 다시 같은 방법을 반복한다.
- 최솟값 찾는데 걸리는 시간 O(N) → 세그먼트 트리로 풀면 O(logN)
- 최솟값의 인덱스를 넣어줘야 한다.

>[가장 긴 증가하는 부분수열2_12015](http://icpc.me/12015)
- 부분수열1 문제와 차이점 : n 제한
- N<=1,000,000 1<=A[i]<=1,000,000
- 세그먼트 트리를 이용한다.
- tree[i] : 수 i를 마지막으로 하는 가장 긴 증가 부분 수열의 길이로 놓고 푼다.

>[가장 긴 증가하는 부분수열3_12015](http://icpc.me/12015)
- 이번엔 범위가 -10억<=A[i]<=10억이기 때문에 세그먼트 트리를 만들 수없다.
- 수를 정렬하고 차례대로 1, 2, 3 을 부여하면 수의 범위가 1에서 N까지로 바뀌기 때문에 세그먼트 트리를 이용해서 풀 수 있다.

>[굉장한 학생_2336](http://icpc.me/2336)
- tree[i]에 1번 시험을 i등한 학생의 3번 시험 등수

---
## 02 합 구하기(p.38)

>[터보소트_3006](http://icpc.me/3006)
- tree[i] 입력으로 주어진 A[i]가 정렬 되었으면 0 아니면 1.
- 이동할때 트리의 왼쪽 / 오른쪽에 있는 1의 갯수만큼 움직이게 된다.

>[영화수집_3653](http://icpc.me/3653)
- N+M개의 배열을 잡고 M+1 ~ M+N에 영화를 놓는다.
- 한 칸씩 앞으로 옮기면서 푼다.

>[공장_7578](http://icpc.me/7578)
- A[i] < A[j]이면서 B[i] > B[j]인 것 찾기.
- A[i]의 왼쪽에 있으면서 B[i]에선 오른쪽에 있는 것.
- tree[i] 오른쪽 1들의 합을 구한다.

---
## 03 합 구하기 2(p.61)

>[나무 심기_1280](http://icpc.me/1280)
- x4가 오른쪽에 심어졌을때 x4-x1 + x4-x2 + x4-x3 = 3*x4 - (x1+x2+x3) = cnt*x4-dist
- 왼쪽에 심어졌을때 x1-x4 + x2-x4 + x3-x4 = (x1+x2+x3) - 3*x4 = dist - cnt*x4
- 왼쪽 오른쪽을 따로 계산해줘야한다.
- 왼쪽 나무 비용 * 오른쪽 나무 비용

>[라운드 로빈 스케줄러_12016](http://icpc.me/12016)
- 완료되는 시간 격차 * 남은 것의 수 - 트리 오른쪽에 완료 안된것 수를 빼서 시간을 구할 수 있다.
- O(N*logN)

>[불만 정렬_5012](http://icpc.me/5012)
- i < j < k 이면서 A[i] > A[j] > A[k]인 쌍의 갯수 구하기

>[음주 코딩_5676](http://icpc.me/5676)
- 음수: -가 홀수번 나옴 → 1(트리에 넣을 때)
- 양수: -가 짝수번 나옴 → 0
- 0 : 0이 등장함 → inf

---
## 04 K번째 찾기(p.83)
- 세그먼트 트리를 이용해서 log N만에 찾기

>[사탕상자_2243](http://icpc.me/2243)
- 왼쪽 / 오른쪽 어디에 있는지 찾아 들어가기.

>[중앙값 측정_9426](http://icpc.me/9426)

>[순열_1849](http://icpc.me/1849)
- i 앞에 i보다 큰 수가 a[i]개 있다.
- N 제한 때문에 세그먼트 트리 이용해야 한다.

>[조세퍼스 문제_1168](http://icpc.me/1168)
