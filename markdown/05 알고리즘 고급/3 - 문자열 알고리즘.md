# Chapter 3 문자열 알고리즘

---
## 01 KMP(p.2)

#### 문자열 매칭 알고리즘

- 문자열 S에서 패턴 P를 찾는 알고리즘.
- S에서 가장 먼저 나타나는 P를 찾아야 한다.
- 앞에서부터 하나하나 비교하면 O(|S|\*|P|)가 걸린다.(|S| = S의 길이)
- 너무 오래 걸려서 KMP를 이용한다.

#### KMP

- Knuth, Morris, Prett가 만듬.
- pi[i]를 이용한다.
	- P의 i까지 부분 문자열에서 prefix == suffix가 될 수 있는 부분 문자열 중에서 가장 긴 것의 길이가 담긴다.
	- prefix = 맨 앞부터 시작하는 부분 문자열.
	- suffix = 맨 뒤로 끝나는 부분 문자열.
	- prefix가 i까지 부분 문자열과 같으면 안된다.
- O(|P|)까지 줄일 수 있다.
- pi 배열 구하는데 걸리는 시간 O(|P|).
- 문자열 매칭하는 데 걸리는 시간 O(|S|+|P|).

>[찾기_1786](http://icpc.me/1786)

---
## 02 KMP 문제 풀이(p.54)

>[광고_1305](http://icpc.me/1305)
- 광고판 크기 L, 광고 문구 길이 N
- 가능한 광고 문구 길이 중 가장 짧은 것 찾기.
- 광고의 suffix가 prefix와 같은 것 중 가장 긴 것을 뺀다.
- 가장 짧은 광고의 길이를 구할 수 있다.
- L - pi[L]

>[Cubeditor_1701](http://icpc.me/1701)
- 소문자 5000개 이하로 구성된 문자열 S.
- 두 번 이상 등장하는 부분 문자열 중에서 가장 긴 것의 길이를 구하는 문제.
- 모든 부분문자열은 어떤 suffix의 prefix 혹은 prefix의 suffix라고 볼 수 있다.

---
## 03 Trie, Aho-corasick(p.64)

- 정수 비교 : O(1)
- 문자열 비교 : O(문자열의 길이)
- BST에 넣을 때, 탐색할 때 역시 마찬가지로 문자열의 길이만큼 곱해져서 더 걸린다.
- 이 때 Trie 자료구조를 이용한다.

#### Trie(트라이)

- 문자열을 다룰 때 효율적인 자료구조.
- depth : 문자열의 길이를 의미한다.
- 앞 글자부터 하나 하나 트리에 넣는다.
- 문자열이 존재하는지 안하는지 찾는데 걸리는 시간 : O(길이)
- Parent 들이 모두 Prefix.
- 한 글자씩 넣기 때문에 있지 않은 문자열이 노드로 존재할 수 있다.
  - 실제 단어인지 중간 과정에서 나온 단어인지 확인하기 위해 valid(bool)을 이용한다.

>[Boggle_9202](http://icpc.me/9202)
- valid와 자식을 저장할 수 있는 children 선언, 모두 -1로 초기화한다.

>[전화번호 목록_5052](http://icpc.me/5052)
- 한 번호가 다른 번호의 접두어이면 안된다.
- 즉 Prefix이면 안된다.
- valid 한 것의 자식이 있으면 일관성이 없다.

#### Aho-corasick

- KMP에서의 pi를 Trie에서 구현하는 것.
	- pi[n] : n이 나타내는 문자열 s의 suffix이면서 trie에 포함된 가장 긴 문자열.
- S 1개, P가 M개 있을때 KMP를 M번 돌리는 건 너무 오래 걸린다. 이때 Aho-corasick을 이용한다.
	- KMP : prefix == suffix 중 가장 긴 것의 길이.
- Trie에는 모든 prefix가 존재하기 때문에 Trie에 존재하는 Node로
- Trie에 존재하면서 어떤 노드의 suffix 중에서 가장 긴것을 찾는 것.
- 찾으려고 하는 문자열은 valid하게.
- 하나 하나 따라가면서 valid하면 +1.
- 없으면 pi로 가서 다시 따라가기.
- 하나의 변수가 더 필요한데, 노드를 방문했을 때 찾았다고 할 수 있는 단어 저장.
- pi 만드는 법
	- 문자열의 suffix는 길이가 짧은 것이기 때문에 BFS 탐색(depth가 문자열의 길이이기 때문에).

>[문자열 집합 판별_9250](http://icpc.me/9250)

>[돌연변이_10256](http://icpc.me/10256)

---
## 04 Suffix Array 1

- 접미사 배열 : 문자열 S의 모든 suffix를 구해서 사전 순으로 정렬한 자료구조.
-

>[접미사 배열_11656](http://icpc.me/11656)
- 정렬할때 걸리는 시간 O(N*logN)에 문자열의 길이 N을 곱한 O(N^2*logN)이 걸린다.

>[접미사 배열 2_13013](http://icpc.me/13013)
- 접미사 배열이 주어지고 그 접미사 배열을 만들 수 있는 문자열 중에서 서로 다른 문자의 개수가 최소가 되는 문자열 구하기.
- 문자열 S의 접미사의 접미사도 S의 접미사가 되는 점을 이용해서 문제를 푼다.
- S[i+1]보다 S[j+1]이 앞서면 S[j]에 S[i]와 같은 값이 올 수 있다.
- 앞서지 않는다면 S[j]에 S[i]보다 큰 값이 와야 한다.
- S[n] = -1 인 이유는 빈 문자열 일때 가장 앞선 값이어야 하기 때문이다.

---
## 05 Suffix Array 2(p.119)

- 접미사 배열을 빠르게 만들기 : O(Nlog^2N)에 구하기.
	- 길이 1로 정렬
	- 길이 2로 정렬
	- 길이 4로 정렬
	- ...
	- 즉 정렬 O(N*logN)\*logN
- 첫 글자만 봐서 그룹으로 묶기.
- 2글자를 기준으로 정렬하기.
	- 그룹 번호 비교.
	- 같으면 한 글자씩 지운 접미사의 그룹 번호 비교.
- 4글자를 기준으로 정렬
	- ...
- ...

>[접미사 배열 2_13264](http://icpc.me/13264)

>[서로 다른 부분 문자열의 개수_11478](http://icpc.me/11478)
- 모든 부분 문자열은 suffix의 prefix이다.

#### LCP(Longest Common Prefix)

- 가장 긴 Prefix의 길이.

>[서로 다른 문자열의 개수 2_11479](http://icpc.me/11479)

---

## 06 Suffix Array 3

#### 기수 정렬(Radix Sort)
- 낮은 자리수부터 정렬해 나가는 것.
	- 1의 자리 기준으로 정렬.
	- 그것을 10의 자리 기준으로 정렬.
	- ...
- 시간 복잡도: O(dN) (d:수의 자리, N:수의 개수)

#### 접미사 배열
- N개의 문자열을 기수 정렬하는데 걸리는 시간 : O(N)
- 정렬을 log N번 반복
- 시간 복잡도: O(NlgN)

>[Suffix Array_9248](http://icpc.me/9248)
- LCP[i] = i번째 Suffix와 i-1번째 Suffix의 LCP 길이.

>[Cubeditor_1701](http://icpc.me/1701)
- 모든 접미사를 구하고 LCP 길이의 최대값을 구한다.

>[공통 부분 문자열_5582](http://icpc.me/5582)
- 두 문자열에 등장하는 부분 문자열 중에서 가장 긴 것을 찾는 문제.
- LCS(substring)
- 다이나믹으로 풀기
	- A[i]==B[j]
		- D[i][j] = D[i-1][j-1]+1
	- A[i]!=B[j]
		- D[i][j] = 0
- Suffix Array로 풀기
	- 두 문자열의 접미사 배열을 구하고 합친다.
	- 다른 문자열끼리의 LCP를 구한다.
	- Suffix Array를 하나만 구해도 풀 수 있다.
	- 같은 문자가 반복될때 문제가 될 수 있다.
	- 합칠 때 사이에 '#' 추가한다.

>[Hidden Password_3789](http://icpc.me/3789)
- 길이가 N인 문자열 S에서 S의 가장 왼쪽 글자를 오른쪽에 붙여가면서 만들 수 있는 단어는 N개가 있다.
- 그 때 사전 순으로 가장 앞서는 단어 찾기.
- 글자의 길이를 2배로 해서 접미사 배열을 만든다.
- 접미사 번호가 원래 문자열의 길이보다 작은 것 중 첫번째가 정답이 된다.
- 같을 땐 인덱스가 뒤에 있는 것을 먼저 오게 정렬한다.

>[가장 긴 팰린드롬 부분 문자열_13275](http://icpc.me/13275)
- 문자열 S와 S를 뒤집은 것을 만든다.
- 사이에 #을 넣어 합친다.
- 공통 부분 문자열 문제와 비슷하게 푼다.
- LCP가 가장 긴게 팰린드롬 문자열이 된다.
