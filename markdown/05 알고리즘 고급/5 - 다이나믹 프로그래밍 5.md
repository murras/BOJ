# Chapter 5 다이나믹 프로그래밍 5

---
## 01-04 확률/기대값 다이나믹 1-4

#### 기대값 DP

>[토끼의 이동_13247](http://icpc.me/13247)
- popcount: 2진수로 나타냈을때 1의 갯수 count.

>[공의 충돌_13249](http://icpc.me/13249)
- N이 작아서 모두 구해본다.

>[축구_1344](http://icpc.me/1344)
- 간격마다 각 팀이 최대 1점 득점 가능.
- 경기 끝난 후 적어도 한 팀이 골을 소수로 득점할 확률을 구하는 문제.
- D[N][A][B] : N번째에서 스코어가 A:B일 확률
	-	A가 득점(D[N-1][A-1][B] * PA * (1-PB))
	- B가 득점(D[N-1][A][B-1] * (1-PA) * PB)
	- 양팀 모두 득점(D[N-1][A-1][B-1] * PA * PB)
	- 양팀 모두 득점하지 못함(D[N-1][A][B] * (1-PA) * (1-PB))
- D[0][0][0] = 1.0

---
## 02 확률/기대값 다이나믹 2(p.19)

>[복권_1359](http://icpc.me/1359)
- 당첨 번호 M개 중에 K개가 같고, N-M개 중에 M-K개가 같으면 된다.
- C[M][K] * C[N-M][M-K]

#### 기대값 다이나믹

>[주사위 게임_13250](http://icpc.me/13250)
- 주사위 던질 때 마다 윗면에 적힌 수만큼 사탕을 받는다.
- 사탕을 적어도 N개 받기 위해 던져야 하는 횟수의 기댓값 구하기.
- D[N] = 사탕을 적어도 N개 받기 위해 던져야 하는 횟수의 기댓값(값 * 확률)
- D[N-1...N-6] + 1 의 1/6을 곱해서 더한다.

>[조약돌 꺼내기_13251](http://icpc.me/13251)
- i번색 조약돌: A[i]
- 첫번째로 꺼낸 조약돌이 i번색일 확률 : A[i] / total
- 두번째로 꺼낸 조약돌이 i번색일 확률 : (A[i]-1) / (total-1)
- K개의 조약돌이 모두 i번색일 확률 : 곱((A[i]-j]) / (total-j)) (0<=j<K)

>[카지노_13252](http://icpc.me/13252)
- N명이 방문, K개의 라운드
- 각 플레이어가 M개의 영역 중 하나에 칩을 놓는다.
- 딜러가 M개의 영역 중에 하나를 랜덤으로 고른다.
- 딜러가 고른 영역에 칩을 놓은 사람은 게임에서 제외된다.
- 최적의 방법으로 진행했을 때, 적어도 한	사람이 게임을 승리할 확률 구하기.
- 두 가지 문제
	- 각 라운드에서 최적의 전략 찾기.
	- 적어도 한 사람은 게임을 승리하는 최적의 전략 찾기.
- 각 영역은 적어도 N/M(내림)개의 동전이 있다.
- N%M개의 영역에는 N/M(올림)개의 동전이 있게 된다.
- D[N][K] = 처음 N명이 있고, 게임이 K라운드로 이루어져있을 때 적어도 한명이 승리할 확률
	- D[N][K] >= D[N-N/M(올림)][K-1]
- N/M(올림)개의 동전이 있는 영역이 선택될 확률 P = (N%M)/M
- N/M(내림)개의 동전이 있는 영역이 선택될 확률 1-P
- D[N][K] = p * D[N-N/M(올림)][K-1] + (1-p) * D[N-N/M(내림])][K-1]

>[토러스_13253](http://icpc.me/13253)
- E[node] = 정점 node에서 처음으로 도착하는 기댓값.
- 기댓값 = 확률의 합 * 값
- x에서 x-1로 갈 때 : E[x-1]+1 
- x에서 x+1로 갈 때 : E[x+1]+1
- x에서 x-1, x+1로 갈 확률은 각각 1/2이다.
- E[x] = (E[x-1]+E[x+1])/2 + 1
- E[0] = 0
- E[cnt] = (E[cnt-1]+E[0])/2 + 1 = E[cnt-1]/2 + 1
- E[x] 를 정리하면 일반항을 구할 수 있다.
    - E[x] = 2*E[x-1]-E[x-2]-2
    - E[x] = a[x]*E[1] + b[x] 꼴로 나타낸다.

>[연휴_13254](http://icpc.me/13254)
- 가족의 선택은 독립적. 
- 어떤 가족이 어떤 도로를 선택할 확률 구하기.
- 각각의 도로에 확률을 구하고 모두 더한다.
- 트리 -> 정점 이동할 수 있는게 하나밖에 없다.

>[동전 뒤집기_13255](http://icpc.me/13255)
- p = A[i] / N
- 홀수 단계 일 때는 1-p



>[생태학_13257](http://icpc.me/13257)
- D[d][m] = d일이 지난 후, m마리의 새에 측정기가 부착되어 있을 확률.
- p(add, prev) = 이 영역에 측정기가 부착된 새가 prev마리 일때 add마리의 새에 측정기가 새로 부착될 확률.
	- m마리가 모두 부착 되어 있지 않을 때
		- D[d-1][m]*p(0,m)
	- 1마리에 부착해야 할때
		- D[d-1][m-1]*p(1,m-1)
	- ...
	- c마리
		- D[d-1][m-c]*p(c,m-c)
- p를 구해야 한다.
	- 측정기가 부착되지 않은 새의 수 : N-prev
	- 측정기가 부착된 새의 수 : prev
	- C(N-prev,add)*C(prev,c-add)
	- C (Combination)

>[랜덤소트_1521](http://icpc.me/1521)
- 순열이 주어 졌을 때 i<j이면서 A[i]>A[j]인 임의의 쌍을 교환 하는 것.
- D[A] = 순열 A를 정렬하는데 필요한 교환 횟수의 기댓값.
- N<=8 (8!=40320개의 순열 갯수)
- 모든 순열을 만들어본다.

>[복권+은행_13258](http://icpc.me/13258)
- D[w][win] = w주에 강호가 win 번 이겼을 때 강호 잔고의 기댓값.
- w주에 복권에 당첨될 확률 p = (A[0]+t*j)/(total+w*J)
- D[w][win] = 당첨되었을때 + 안되었을때
- = p*D[w+1][win+1]+(1-p)*D[w+1][win]

---
## 05 Knuth Optimization

### DP 최적화
- 점화식이 특정한 형태를 만족하고, 어떤 조건을 만족할 때 DP 최적화를 적용해볼 수 있다.
	- Knuth Optimizaion
	- Divide & Conquer
	- Convex Hull Optimization

#### Knuth Optimization
- 점화식 : D[i][j] = min(D[i][k]+D[k][j]+C[i][j]) (i<k<j)
- C[i][j] = cost
- P[i][j-1] <= P[i][j] <= P[i+1][j]
- D[i][j] 구할때 O(N^2), k 구할때 O(N)이어서 O(N^3)이다.
- k의 범위를 줄여 O(N^2)으로 줄일 수 있다.

>[파일 합치기_11066](http://icpc.me/11066)
- D[i][j] = i번째 장부터 j번째 장까지 합쳤을 때 필요한 최소 비용
- D[i][j] = D[i][k] + D[k+1][j] + C[i][j]
- C[i][j] = A[i] + ... + A[j]
- Quadrangle inequality와 Monotonicity가 만족해야 한다.

>[문자열 자르기_13260](http://icpc.me/13260)
- 길이가 N인 문자열 두조각으로 자르는데 필요한 비용 N.
- D[i][j] = i부터 j까지 자르는 비용
- D[i][j] = D[i][k] + D[k][j] + A[j]-A[i]
	- A[j]-A[i] : k에 대해 독립적

>[행렬 곱셈 순서_11049](http://icpc.me/11049)
- D[i][j] = i 행렬부터 j 행렬까지 곱했을 때 곱셈 연산의 최솟값
- A[i] = i번째 행렬 크기(A[i][0]*A[i][1])
- D[i][j] = min(D[i][k] + D[k+1][j] + A[i][0]*A[k][1]\*A[j][1])
	- A[i][0]*A[k][1]\*A[j][1] : 이 부분이 k에 대해 독립적이지 않아 Knuth Optimization을 적용할 수 없다.

---
## 06 Divide & Conquer Optimization

- 점화식 : D[i][j] = min(D[i-1][k] + C[k][j]) (k<j)
- P[i][j] = D[i][j]가 최소가 되는 k일때 P[i][j]<=P[i][j+1]을 만족하거나
- Quadrangle inequality를 만족해야 한다.
- O(NM^2)을 O(NMlogM)으로 줄일 수 있다.

>[탈옥_13261](http://icpc.me/13261)
- L개 칸, i번방 탈옥력 C[i]
- 간수 G명, 탈옥 위험도 C[i]*i번방을 감시하는 간수가 감시하는 죄수의 수
- D[i][j] = i명의 간수가 j번 감옥까지 감시하고 있을 때, 탈옥 위험도의 최솟값.
- 전 상황 : i-1명의 간수가 k번째 감옥까지 감시.
- 다음 간수 : k+1번째 감옥부터 j번째 감옥까지 감시.
- D[i][j] = D[i-1][k] + cost[k+1][j]
	- cost[k+1][j] = (sum[j]-sum[k])*(j-k)
- P[i][j] = D[i][j]가 최소가 되는 k.
- P[i][j] <= P[i][j+1].


>[수열의 OR 점수_13262](http://icpc.me/13262)
- 크기가 N인 수열 A와 정수 K가 주어진다.
- 수열을 K개의 그룹으로 나눈다.
- 그룹은 연속 되어야 한다.
- 모든 원소는 한 그룹에 포함.
- 그룹의 점수는 그룹에 속한 수를 모두 or한 값.
- 수열의 점수는 그룹의 점수를 모두 합한 값.
- D[i][j] = i개의 수를 j개의 그룹으로 나누었을 때, 그룹 점수의 최댓값.

---
## 07 Convex Hull Optimization

- D[i] = min(D[j] + B[j]*A[i]) (j<i)
	- O(N^2) : CH opt 적용 하면 O(N)까지 줄일 수 있다.
- B[j] >= B[j+1], A[i] <= A[i+1]
	- B : 기울기 감소
	- A : x 좌표 
- 방법
	- 모든 선분을 기울기가 감소하게 정렬한다.
	- 하나씩 합친다.
	- 새로운 선분이 추가될 때마다 정답이 될 수 있는지 확인한다.
	- 정답이 될 수 없는 일부 선분은 제거한다.
	- 스택 사용.
- l1, l2 선분이 있고 l3 선분이 추가가 될때 l1-l3 교차점이 l1-l2 교차점 보다 왼쪽에 있다면 l2는 필요 없다.

>[나무 자르기_13263](http://icpc.me/13263)
- 나무 높이 : A[i]
- i번 나무에 전기톱을 사용하면 높이가 1 감소
- 전기톱은 사용할때 마다 충전.
- 완전히 잘린 나무의 번호 중 최댓값이 i면 B[i]만큼 충전.
- 완전히 잘린 나무가 없으면 충전할 수 없음.
- 모든 나무를 완전히 자르는데 필요한 충전 비용의 최솟값 구하기.
- D[i] = min(D[j], B[j]*A[i]) (j<i)
- A[i] <= A[i+1]
- B[i] >= B[i+1]

>[땅따먹기_6171](http://icpc.me/6171)
- N개의 땅을 사려고 한다(1<=N<=50000)
- 땅은 W[i]*H[i].
- 여러개의 땅을 살때 값: 해당 땅 중 W[i]의 최댓값 * 해당 땅 중 H[i]의 최댓값
- 땅을 모두 사는 비용의 최솟값 구하기.
- 땅따먹기에서는 포함되는 작은 땅은 필요가 없다.
	- W도 크면서 H도 큰 직사각형을 없앤다.
	- 직사각형 높이는 증가하고, 너비는 감소하게 만들 수 있다.
	- Convex Hull opt가 가능하다.
- D[i] = min(D[j-1] + A[i].h*A[j].w)

>[특공대_4008](http://icpc.me/4008)
- 1~N 병사를 여러개의 그룹으로 나눈다.
- i~j 전투력 x = i번~j번 전투력의 합
- sum(i,j), adjust(i,j)
	- sum(i,j) = x[i] + ... + x[j]
	- adjust(i,j) = A*sum(i,j)^2 + B\*sum(i,j) + C
- D[i] = max(D[j] + adjust(j+1,i))